template<class T>
struct SegmentTree {
	T *segT;  int segT_len;
	SegmentTree() :segT_len(0) {}
	SegmentTree(int len) :segT_len(len) { segT = new T[4 * len + 10]; }
	void build(int segT_node, int l, int r) {
		if (l == r) {
			segT[segT_node] = arr[l];
			return;
		}
		int mid = (l + r) >> 1;
		build(2 * segT_node + 1, l, mid);
		build(2 * segT_node + 2, mid + 1, r);
		segT[segT_node] = segT[segT_node * 2 + 1] * segT[segT_node * 2 + 2] % MOD;
	}
	void update(int segT_node, int l, int r, int global_index, T val) {
		if (l == r) {
			segT[segT_node] = arr[global_index] = val%MOD;
			return;
		}
		int mid = (l + r) >> 1;
		if (global_index <= mid)update(2 * segT_node + 1, l, mid, global_index, val);
		else update(2 * segT_node + 2, mid + 1, r, global_index, val);
		segT[segT_node] = segT[segT_node * 2 + 1] * segT[segT_node * 2 + 2] % MOD;
	}
	T query(int segTree_node, int l, int r, int global_l, int global_r) {
		if (l > global_r | r < global_l)return 1;
		if (l >= global_l & r <= global_r)return segT[segTree_node];
		int mid = (l + r) >> 1;
		return query(2 * segTree_node + 1, l, mid, global_l, global_r)*query(2 * segTree_node + 2, mid + 1, r, global_l, global_r) % MOD;
	}
};